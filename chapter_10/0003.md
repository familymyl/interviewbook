---
search:
    keywords: ['约瑟夫', '报数']

---


# 约瑟夫环

# 问题描述
39 个犹太人与Josephus及他的朋友躲到一个洞中，39个犹太人决定宁愿死也不要被敌人抓。于是决定了自杀方式，41个人排成一个圆圈，由第1个人开始报数，每报数到第2人该人就必须自杀。然后下一个重新报数，直到所有人都自杀身亡为止。然而Josephus 和他的朋友并不想死，Josephus要他的朋友先假装遵从，他将朋友与自己安排在第16个与第31个位置，于是逃过了这场死亡游戏。

试用java代码表现上述推导过程。

## 解法1

{%ace edit=false, lang='java', theme='monokai'%}
public static void main(String[] args) {
  int n = 41;
  int k = 3;
  LinkedList<Integer> list = new LinkedList<>();
  for (int i = 1; i <= n; i++) {
    list.add(i);
  }
  System.out.println(list);
  int i = 1; // 开始报数
  while (list.size() > 1) { // 循环直到剩最后一人
    if (i % k != 0) { // 如果报的不是k的倍数，存活，进入下一轮
      list.addLast(list.removeFirst());
    } else { // 是k的倍数，被杀
      list.removeFirst();
      System.out.println(list);
    }
    i++; // 报数加1
  }
}
{%endace%}

## 解法2

{%ace edit=false, lang='java', theme='monokai'%}
/*
 * 对于总人数n，报数间隔k，f(i) 表示第i轮被杀的人
 * 有如下公式：
 * 注意人的编号从0开始
 * f(1) = 0; 
 * f(i) = (f(i-1) + k) % i; (i>1)
 * 
 * 如果人的编号从1开始，公式要变为
 * f(1) = 1; 
 * f(i) = (f(i-1) + k - 1) % i + 1; (i>1)
 */
public static void main(String[] args) {
  int n = 41;
  int k = 2;
  int f = 0;
  for (int i = 2; i <= n; i++) {
    f = (f + k) % i;
  }
  System.out.println(f+1);
}
{%endace%}

## 变体
100个人围成一圈，数到3和3的倍数时出圈，问剩下的人是谁？



---


